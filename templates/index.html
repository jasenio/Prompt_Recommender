<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ChatUI + Prompt RS</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
  <div class="main-container">

    <!-- generic chatbot interface -->
    <div class="chat-container">
      <header>
        <h1>Chat with GPT</h1>
      </header>

      <!-- message area -->
      <main id="chat-box" class="chat-box"></main>

      <!-- input area -->
      <footer class="input-area">
        <textarea id="user-input" rows="1" placeholder="Type your message..."
          oninput="autoResize(this)"
          onkeydown="if(event.key==='Enter' && !event.shiftKey){event.preventDefault();sendMessage();}">
        </textarea>
        <button onclick="sendMessage()">Send</button>
      </footer>

      <!-- recommendations toggle -->
      <button id="see-recs-chip"
              class="chip"
              style="display:none;"
              disabled
              onclick="openRecommendations()">
        Loading recommendations…
      </button>
    </div>

    <!-- promptRS sidebar -->
    <div class="promptrs-container" id="promptrs">
      <div class="promptrs-header">
        <h2>Prompt RS</h2>
        <button aria-label="Close recommendations"
                onclick="closeRecommendations()"
                class="close-btn">✕</button>
      </div>

      <!-- list (carousel style) -->
      <div id="prompt-list" class="prompt-list">
        <!-- skeleton overlay -->
        <div id="skeletons" class="skeletons" aria-hidden="true"></div>

        <!-- items rendered -->
        <div id="items"></div>
        <div id="tail-skeletons" class="tail-skeletons" aria-hidden="true" style="display:none;"></div>

        <!-- infinite scroll -->
        <div id="sentinel" class="sentinel" aria-hidden="true"></div>
      </div>
    </div>

  </div>

  <!-- scripts -->
  <script>
    // store session info + feedback
    function getSessionId() {
      let sid = localStorage.getItem("session_id");
      if (!sid) {
        sid = crypto.randomUUID();
        localStorage.setItem("session_id", sid);
      }
      return sid;
    }
    const SESSION_ID = getSessionId();
    let current_response_id;

    // send feedback to pgsql
    async function sendFeedback(action, meta) {
      const payload = {
        session_id: SESSION_ID,
        timestamp: new Date().toISOString(),
        action,
        meta
      };
      try {
        await fetch("/feedback", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
      } catch (err) {
        console.warn("Failed to log feedback:", err);
      }
    }

    // send message = (1) generic chatbot + (2) fetch recommendations
    async function sendMessage() {
      const input = document.getElementById("user-input");
      const message = input.value.trim();
      if (!message) return;

      appendMessage("You", message);

      closeRecommendations();
      input.value = "";
      input.style.height = "auto";
      positionChip();

      appendMessage("Bot", "<em>Thinking...</em>");
      const responseEl = document.querySelector(".bot-msg:last-child p");

      try {
        const res = await fetch('/get', {
          method: 'POST',
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ msg: message, prev_id: current_response_id })
        });
        const data = await res.json();

        responseEl.innerHTML = data.text.replace(/\n/g, "<br>");
        current_response_id = data.new_id;

        // recommend using bot output + original message
        try {
          await fetchRecommendations(message, data.text, 20);
        } catch (recErr) {
          console.warn('Recommendations failed:', recErr);
        }

        

      } catch (err) {
        responseEl.innerHTML = "<span style='color:red;'>Error fetching response.</span>";
      }

      // send [submit] feedback
      sendFeedback("submit", {});
    }

    function appendMessage(sender, text) {
      const chatBox = document.getElementById("chat-box");
      const msgDiv = document.createElement("div");
      msgDiv.classList.add("message", sender === "You" ? "user-msg" : "bot-msg");
      msgDiv.innerHTML = `<p><strong>${sender}:</strong><br>${text}</p>`;
      chatBox.appendChild(msgDiv);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    function autoResize(textarea) {
      textarea.style.height = "auto";
      textarea.style.height = Math.min(textarea.scrollHeight, 250) + "px";
      positionChip();
    }

    // manage recommendation state
    let REC_STATE = "idle";
    let RECS = [];                 // all items
    let NEXT_TOKEN = null;         // optional pagination from backend
    let IS_LOADING_MORE = false;   // guard for load-more

    // carousel specs
    let STRIDE = 98;               // item height + gap (px)
    let VISIBLE_ITEMS = 3;         // visible items in viewport

    // DOM refs for carousel list 
    const listEl = document.getElementById("prompt-list");
    const itemsEl = document.getElementById("items");
    const skelEl = document.getElementById("skeletons");
    const tailSkelEl = document.getElementById("tail-skeletons");
    const sentinelEl = document.getElementById("sentinel");

    // update css config using css vars
    function readCSSConfig() {
      const rootStyles = getComputedStyle(document.documentElement);
      const itemH = parseInt(rootStyles.getPropertyValue("--item-h")) || 88;
      const itemGap = parseInt(rootStyles.getPropertyValue("--item-gap")) || 10;
      const vis = parseInt(rootStyles.getPropertyValue("--visible-items")) || 3;
      STRIDE = itemH + itemGap;
      VISIBLE_ITEMS = vis;
    }

    // control LOADING vs SEE RECS vs IDLE states
    function setRecState(next) {
      REC_STATE = next;
      const chip = document.getElementById("see-recs-chip");

      if (next === "loading") {
        if (chip) {
          chip.textContent = "Loading recommendations…";
          chip.style.display = "inline-block";
          chip.disabled = true; // disable recs while loading
        }
        if (skelEl) renderSkeletons(skelEl, 6); 
      } else if (next === "loaded") {
        if (chip) {
          chip.textContent = "See recommendations";
          chip.style.display = "inline-block";
          chip.disabled = false;
        }
        if (skelEl) skelEl.innerHTML = ""; 
      } else {
        if (chip) {
          chip.style.display = "none";
          chip.disabled = true; // hide recs if not loaded
        }
        if (skelEl) skelEl.innerHTML = "";
      }
      positionChip();
    }

    // control opening / closing recommendations
    function openRecommendations() {
      const chip = document.getElementById("see-recs-chip");
      if (chip && chip.disabled) return;
      if (REC_STATE !== "loaded") return;

      const sidebar = document.getElementById("promptrs");
      const chat = document.querySelector(".chat-container");
      if (!sidebar || !chat) return;

      sidebar.classList.add("open");
      chat.classList.add("with-sidebar");
      chip.style.display = "none";

      requestAnimationFrame(() => {
        renderAllItems();
        updateHighlightedItems();
        listEl?.focus?.();
      });
    }

    function closeRecommendations() {
      const sidebar = document.getElementById("promptrs");
      const chat = document.querySelector(".chat-container");
      const chip = document.getElementById("see-recs-chip");
      if (!sidebar || !chat || !chip) return;

      sidebar.classList.remove("open");
      chat.classList.remove("with-sidebar");
      if (REC_STATE === "loaded") chip.style.display = "inline-block";
      positionChip();
    }

    // fetch and render recommendations
    let LAST_QUERY = "", LAST_BOT_TEXT = "";

    async function fetchRecommendations(query, bot_response, k = 20, page_token = null) {
      try {
        if (!page_token) {
          setRecState("loading");  
        } else {
          IS_LOADING_MORE = true;
          if (tailSkelEl) { tailSkelEl.style.display = "block"; renderSkeletons(tailSkelEl, 3); }
        }

        const res = await fetch("/recommend", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ user_input: query, bot_response, k, page_token })
        });

        if (!res.ok) throw new Error("Server returned " + res.status);

        const payload = await res.json();
        const results = payload.results || [];
        NEXT_TOKEN = payload.next_page_token || null;

        if (!page_token) {
          RECS = results.length ? results : getDummyPrompts();
          LAST_QUERY = query || LAST_QUERY;
          LAST_BOT_TEXT = bot_response || LAST_BOT_TEXT;
          setRecState("loaded");
          listEl.scrollTop = 0;
          renderAllItems();
          updateHighlightedItems();
        } else {
          RECS = RECS.concat(results);
          IS_LOADING_MORE = false;
          if (tailSkelEl) { tailSkelEl.style.display = "none"; tailSkelEl.innerHTML = ""; }
          renderAllItems();
          updateHighlightedItems();
        }

      } catch (err) {
        console.warn("Recommendation fetch failed:", err);
        if (!page_token) {
          RECS = getDummyPrompts();
          setRecState("loaded");
          renderAllItems();
          updateHighlightedItems();
        } else {
          IS_LOADING_MORE = false;
          if (tailSkelEl) { tailSkelEl.style.display = "none"; tailSkelEl.innerHTML = ""; }
        }
      }
    }

    // render all items with clones for infinite scroll
    function renderAllItems() {
      if (!itemsEl) return;
      itemsEl.innerHTML = "";
      
      const totalCards = RECS.length;
      
      if (totalCards > VISIBLE_ITEMS) {

        // use clones to appear at top
        for (let i = totalCards - VISIBLE_ITEMS; i < totalCards; i++) {
          const clone = renderCard(RECS[i], i);
          clone.classList.add("clone");
          itemsEl.appendChild(clone);
        }
      }
      
      // add real items
      RECS.forEach((r, idx) => itemsEl.appendChild(renderCard(r, idx)));
      
      if (totalCards > VISIBLE_ITEMS) {
        // add clones of first to bottom
        for (let i = 0; i < VISIBLE_ITEMS; i++) {
          const clone = renderCard(RECS[i], i);
          clone.classList.add("clone");
          itemsEl.appendChild(clone);
        }
      }
      
      // set initial scroll position to skip top clones
      if (totalCards > VISIBLE_ITEMS) {
        listEl.scrollTop = VISIBLE_ITEMS * STRIDE;
      }
    }

    // update highlighted items based on scroll position
    function updateHighlightedItems() {
      if (!listEl || !itemsEl) return;

      const scrollTop = listEl.scrollTop;
      const listHeight = listEl.clientHeight;
      
      // calculate the center position of the visible area
      const centerScroll = scrollTop + (listHeight / 2);
      const centerIndex = Math.round(centerScroll / STRIDE);
      
      // highlight visible items centered around the center of viewport
      const halfVisible = Math.floor(VISIBLE_ITEMS / 2);
      const startHighlight = centerIndex - halfVisible;
      const endHighlight = startHighlight + VISIBLE_ITEMS;

      const cards = itemsEl.querySelectorAll(".prompt-item");
      const totalCards = cards.length;
      
      cards.forEach((card, idx) => {
        // allow highlighting at the end by not restricting bounds
        let isHighlighted = false;
        
        if (totalCards <= VISIBLE_ITEMS) {
          // highltight all if few items
          isHighlighted = true;
        } else if (centerIndex < halfVisible) {
          // higlight from top - first VISIBLE_ITEMS
          isHighlighted = idx < VISIBLE_ITEMS;
        } else if (centerIndex >= totalCards - halfVisible) {
          // highlight from bottom - last VISIBLE_ITEMS
          isHighlighted = idx >= totalCards - VISIBLE_ITEMS;
        } else {
          // highlight normal range
          isHighlighted = idx >= startHighlight && idx < endHighlight;
        }
        
        if (isHighlighted) {
          card.classList.add("in-viewport");

          // detect center one (middle of the visible band)
          const centerOffset = Math.floor(VISIBLE_ITEMS / 2);
          const centerIdx = startHighlight + centerOffset;
          if (idx === centerIdx) {
            card.classList.add("center-item");
          } else {
            card.classList.remove("center-item");
          }
        } else {
          card.classList.remove("in-viewport", "center-item");
        }

      });
    }

    // handle infinite looping scroll
    function handleInfiniteScroll() {
      if (!listEl) return;

      const scrollTop = listEl.scrollTop;
      const scrollHeight = listEl.scrollHeight;
      const clientHeight = listEl.clientHeight;
      const totalCards = RECS.length;
      if (totalCards === 0) return;

      const threshold = STRIDE * 0.5; // smaller threshold for smoother looping

      // when near top (clone region), jump to mirrored position smoothly
      if (scrollTop <= threshold) {
        const newScrollTop = scrollTop + (totalCards * STRIDE);
        listEl.scrollTo({ top: newScrollTop, behavior: "auto" });
      }
      // when near bottom (clone region), jump up to the mirrored items
      else if (scrollTop >= scrollHeight - clientHeight - threshold) {
        const newScrollTop = scrollTop - (totalCards * STRIDE);
        listEl.scrollTo({ top: newScrollTop, behavior: "auto" });
      }
    }

    function onScrollHandler() {
      updateHighlightedItems();
      handleInfiniteScroll();
    }

    // render each card = (1) title + (2) prompt
    function renderCard(r, absoluteIndex) {
      const meta = r.meta || {};
      const title = r.title || r.task || r.recommendation || meta.recommendation || meta.title || `Doc ${r.doc_id || absoluteIndex}`;
      const promptText =
        r.prompt || r.recommendation || meta.prompt || meta.text || (typeof meta === "string" ? meta : JSON.stringify(meta));

      // legacy
      const similarity = (r.similarity !== undefined) ? ` · sim: ${r.similarity}` : "";

      const div = document.createElement("div");
      div.classList.add("prompt-item");
      div.setAttribute("role", "button");
      div.setAttribute("tabindex", "0");
      div.setAttribute("aria-label", `Use recommendation: ${title}`);

      div.innerHTML = `
        <h3>${escapeHtml(title)}<small class="sim">${escapeHtml(similarity)}</small></h3>
        <p>${escapeHtml(shorten(promptText, 200))}</p>
      `;

      // track if item is inspected
      const useAction = () => {
        const input = document.getElementById("user-input");
        input.value = promptText;
        autoResize(input);
        input.focus();
        sendFeedback("use", { title, promptText, similarity, index: absoluteIndex });
        flashCard(div);
      };

      div.addEventListener("click", useAction);
      div.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          useAction();
        }
      });

      return div;
    }

    function flashCard(el) {
      el.classList.add("used");
      setTimeout(() => el.classList.remove("used"), 600);
    }

    // skeletons
    function renderSkeletons(container, count) {
      const arr = Array.from({ length: count });
      container.innerHTML = arr.map(() => `
        <div class="skeleton-card">
          <div class="skel-title shimmer"></div>
          <div class="skel-line shimmer"></div>
        </div>
      `).join("");
    }

    // render defualt dummy prompts on error
    function getDummyPrompts() {
      return [
        { title: "Example 1", prompt: "Tell me about AI safety" },
        { title: "Example 2", prompt: "How does machine learning work?" },
        { title: "Example 3", prompt: "Explain neural networks" }
      ];
    }

    // ========= Infinite scroll (optional) =========
    const io = new IntersectionObserver(async (entries) => {
      for (const entry of entries) {
        if (!entry.isIntersecting) continue;
        if (!NEXT_TOKEN || IS_LOADING_MORE) continue;
        IS_LOADING_MORE = true;
        if (tailSkelEl) { tailSkelEl.style.display = "block"; renderSkeletons(tailSkelEl, 3); }
        try {
          await fetchRecommendations(LAST_QUERY, LAST_BOT_TEXT, 20, NEXT_TOKEN);
        } catch {
          IS_LOADING_MORE = false;
          if (tailSkelEl) { tailSkelEl.style.display = "none"; tailSkelEl.innerHTML = ""; }
        }
      }
    }, { root: listEl, rootMargin: "200px 0px", threshold: 0 });

    io.observe(sentinelEl);

    // misc helpers
    function shorten(text, max) {
      if (!text) return "";
      return text.length > max ? text.slice(0, max) + "..." : text;
    }

    function escapeHtml(str) {
      if (str === undefined || str === null) return "";
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    // position chip above submit area
    function positionChip() {
      const chip = document.getElementById("see-recs-chip");
      const footer = document.querySelector(".input-area");
      if (!chip || !footer) return;
      const offset = footer.offsetHeight + 12;
      chip.style.bottom = offset + "px";
    }
    window.addEventListener("resize", positionChip);

    // init
    document.addEventListener("DOMContentLoaded", () => {
      readCSSConfig();   
      setRecState("idle");
      positionChip();
    });

    // update css vars on window resize
    window.addEventListener("resize", () => {
      readCSSConfig();
      updateHighlightedItems();
    });

    // handle scrolling for carousel
    listEl.addEventListener("scroll", onScrollHandler);
  </script>

</body>
</html>